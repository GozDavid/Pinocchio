DENSITA` ma solo sulla griglia
qui ci si calcola la varianza sulla griglia, quindi bisogna usare k_for_GM
build_groups.c, L682:  sigmaD = sqrt(Smoothing.TrueVariance[Smoothing.Nsmooth-1]) * GrowingMode(F-1.,1./rlag/params.InterPartDist);  // QUI VERIFICARE


DISPLACEMENTS - sulla griglia e sulla scala del gruppo
in set_obj si usa myk=params.k_for_GM / pow((double)(myobj->M),1./3.);
build_groups.c:  myobj->D=GrowingMode(myobj->z,myk);
build_groups.c:  myobj->D2=GrowingMode_2LPT(myobj->z,myk);
build_groups.c:  myobj->D31=GrowingMode_3LPT_1(myobj->z,myk);
build_groups.c:  myobj->D32=GrowingMode_3LPT_2(myobj->z,myk);

in set_point si usa  myobj->myk=power.k_for_GM;
build_groups.c:  myobj->D=GrowingMode(myobj->z,myobj->myk);
build_groups.c:  myobj->D2=GrowingMode_2LPT(myobj->z,myobj->myk);
build_groups.c:  myobj->D31=GrowingMode_3LPT_1(myobj->z,myobj->myk);
build_groups.c:  myobj->D32=GrowingMode_3LPT_2(myobj->z,myobj->myk);

questo va cambiato con InverseGrowingMode
collapse_times.c:    return 1.+InverseGrowingMode(bc);

DENSITA` al raggio di smoothing, pensiamoci
questo e` per calcolare le CI del collasso ellissoidale
collapse_times.c:  double D_in = GrowingMode(1./amin-1.,1./Smoothing.Radius[ismooth]);

questo e` nello spazio di Fourier, va bene cosi`
questo ha senso ED E` GIUSTO (starci attenti)
fmax-fftw.c:      Dk=GrowingMode(ScaleDep.redshift,params.k_for_GM);
fmax-fftw.c:      Dk=GrowingMode_2LPT(ScaleDep.redshift,params.k_for_GM);
fmax-fftw.c:      Dk=GrowingMode_3LPT_1(ScaleDep.redshift,params.k_for_GM);
fmax-fftw.c:      Dk=GrowingMode_3LPT_2(ScaleDep.redshift,params.k_for_GM);
fmax-fftw.c:		  growth_rate = GrowingMode(ScaleDep.redshift,k_module) / Dk;
fmax-fftw.c:		  growth_rate = GrowingMode_2LPT(ScaleDep.redshift,k_module) / Dk;
fmax-fftw.c:		  growth_rate = GrowingMode_3LPT_1(ScaleDep.redshift,k_module) / Dk;
fmax-fftw.c:		  growth_rate = GrowingMode_3LPT_2(ScaleDep.redshift,k_module) / Dk;

qui tutti i GM li sto calcolando alla scala della griglia, 
quindi k_for_GM deve dare il k giusto per ottenere la varianza sulla griglia
initialization.c:  var_min    = pow(1.686/NSIGMA / GrowingMode(outputs.zlast,0.),2.0);
initialization.c:  Smallest_r -= NSAFE * GrowingMode(params.LastzForPLC,0.) * displ_variance;
initialization.c:  Largest_r += NSAFE * GrowingMode(params.StartingzForPLC,0.) * displ_variance;
initialization.c:      tdis = NSAFE * GrowingMode(z,0.) * displ_variance;
initialization.c:  tdis = GrowingMode(outputs.zlast,0.) * sqrt( DisplVariance(params.InterPartDist) );


questo serve per la MF analitica, che non sappiamo calcolare al momento
write_halos.c:  D=GrowingMode(outputs.z[iout],0.);

DISPLACEMENTS sulla griglia
anche qui tutto con params.k_for_GM
write_snapshot.c:  Dz = GrowingMode(outputs.z[iout],0.);
write_snapshot.c:	/* Dz = GrowingMode(outputs.z[iout],0.); */
write_snapshot.c:  G=GrowingMode(redshift,0.);
write_snapshot.c:  G2  = GrowingMode_2LPT(redshift,0.);
write_snapshot.c:  //G31  = GrowingMode_3LPT_1(redshift,0.);
write_snapshot.c:  //G32  = GrowingMode_3LPT_2(redshift,0.);
